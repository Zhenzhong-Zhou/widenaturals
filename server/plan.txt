1. ssl setup -> handle by Certbot with Nginx in production        ......done
2. server pressure stress test                      .....done
3. general-service -> system-service                .....done
4. http and middleware test no response             .....done
5. env = test how to execute the project
6. fix test cases  ->  can run, fix error           .....done
7. url .env is necessary or not -> .json file       .....done
8. terminate test cannot use control + C -> automation end test     .....done
9. automation run test before run server
10. create user table with password vs using oath like outlook
11. comprehensive to test server as a whole
12. stress-test.yml placeholder ${BASE_URL} somehow cannot replace it
13. db.test.js is this test enough? like graceshut donw db?         .....done
14. creation, initialization, migration, and backup tables
15. hash record id:  const recordId = crypto.createHmac('sha256', secretKey).update(employeeId).digest('hex');
16. Run Migrations Automatically on Start,  Using Lifecycle Hooks, and Programmatically Run Migrations
17. Fix duplicate code create employee in admin and manager routes
18. routes.js import and code order need to enhance or not? and auth/login?
19. hash id? ID Exposure in URLs and APIs, Data Masking and Redaction
20. CI/CD Pipeline? in a GitHub Actions workflow, Deployment Process
21. enhance login
22. backup db, creation, initial setup, migrations cron 3w
23. test cron, middleware token, token related function


----------------------
Finding the User:

The function first attempts to find a user by the provided username using User.findOne({ username }).
Password Verification:

The password entered by the user is compared to the hashed password stored in the database using bcrypt.compare(password, user.password).
JWT Creation:

If the username and password are correct, a JWT is created using jwt.sign. The payload contains the user ID and role (you can add more fields as needed). The token is signed with a secret key stored in your environment variables.
Token Return:

The generated token is then returned to the client. The client can use this token to authenticate future requests.
Error Handling:

The function includes basic error handling for common issues, such as incorrect credentials or server errors.
Security Considerations:
Use HTTPS: Ensure that your application uses HTTPS to secure the transmission of tokens.
Environment Variables: Store your JWT_SECRET securely and never hardcode it in your source code.
Token Expiry: Adjust the token expiration time according to your security requirements.
This is a basic implementation. Depending on your requirements, you might need to add more features, such as:

Account Lockout after multiple failed login attempts.
Two-Factor Authentication (2FA) for added security.
Refresh Tokens if you want to issue short-lived access tokens and refresh tokens to manage sessions.



Two-Factor Authentication (2FA): If your application requires higher security,
implement 2FA as an additional step after a successful password verification.

Client-Side Validation: Perform basic validations on the client side, like checking for empty fields, but always enforce the security checks server-side.

Security Best Practices: Ensure all responses are secured using HTTPS to protect data in transit.
Also, consider logging out users from all sessions if they change their password or after a specific period of inactivity.


---------- Control Access -----

Best Practice Recommendation
Consider a Hybrid Approach:

Role Hierarchy: Implement a hierarchical role system where the "manager" role automatically includes all permissions of the "employee" role. This way, when you assign the "manager" role to a user, they automatically inherit "employee" permissions.
Separate Permissions: If you need to differentiate between "manager"-specific and "employee"-specific actions, you can still have separate permissions within each role. The "manager" role would have additional permissions on top of the inherited "employee" permissions.
Example Design:
Role Hierarchy:

employee role: Base level permissions.
manager role: Inherits all employee permissions and adds additional manager-specific permissions.
Role Inheritance Logic:

In your application, define that the manager role automatically includes employee permissions.
Ensure that when you assign the manager role, the system treats the user as having both manager and employee permissions.